// ÏÑúÎ≤ÑÎ•º ÎßåÎì§Í∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïú ÎèÑÍµ¨(Î™®Îìà) Î∂àÎü¨Ïò§Í∏∞
const express = require('express'); // Ïõπ ÏÑúÎ≤ÑÎ•º ÎßåÎì§Í∏∞ ÏúÑÌïú ÎèÑÍµ¨(Express)
const mariadb = require('mariadb'); // MariaDB Ïó∞Í≤∞ Î™®Îìà
const cors = require('cors'); // CORS Î∂àÎü¨Ïò§Í∏∞
const moment = require('moment-timezone');
const axios = require('axios');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt'); // ÎπÑÎ∞ÄÎ≤àÌò∏ Ìï¥Ïã±Ïö©
require('dotenv').config(); // ÌôòÍ≤Ω Î≥ÄÏàò Î°úÎìú

// JWT ÎπÑÎ∞Ä ÌÇ§
const JWT_SECRET = process.env.JWT_SECRET

// OpenAI Î™®Îìà Ï∂îÍ∞Ä
const OpenAI = require("openai");

// ÏÑúÎ≤Ñ ÎßåÎì§Í∏∞ + Ïã§ÌñâÌï† Ìè¨Ìä∏ Î≤àÌò∏ ÏÑ§Ï†ï
const app = express(); // ÏÑúÎ≤ÑÎ•º ÎßåÎì†Îã§ (Ïù¥ Î≥ÄÏàòÏóê ÏÑúÎ≤Ñ Í∏∞Îä•ÏùÑ Ï†ÄÏû•)
const PORT = 8000;     // ÏÑúÎ≤ÑÍ∞Ä ÏÇ¨Ïö©Ìï† Ìè¨Ìä∏ Î≤àÌò∏

// 'public' Ìè¥ÎçîÎ•º Ï†ïÏ†Å ÌååÏùº Ï†úÍ≥µ Ìè¥ÎçîÎ°ú ÏÑ§Ï†ï
app.use(express.static('public'));
app.use(cors()); // Î™®Îì† ÏöîÏ≤≠Ïóê ÎåÄÌï¥ CORS ÌóàÏö©
// POST ÏöîÏ≤≠ÏùÑ Ï≤òÎ¶¨ÌïòÍ∏∞ ÏúÑÌï¥ expressÏùò json() ÏÇ¨Ïö©
app.use(express.json()); // body-parserÍ∞Ä ÌïÑÏöîÌïòÏßÄ ÏïäÏùå

// MariaDB Ïó∞Í≤∞ db ÏÉùÏÑ±
const db = mariadb.createPool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

const API_BASE_URL = "https://port-0-server-m7tucm4sab201860.sel4.cloudtype.app"

// Ïó∞Í≤∞ ÌôïÏù∏
db.getConnection()
  .then(conn => {
    console.log('MariaDB Ïó∞Í≤∞ ÏÑ±Í≥µ!');
    conn.release(); // ÏÇ¨Ïö© ÌõÑ Ïó∞Í≤∞ Î∞òÌôò
  })
  .catch(err => console.error('MariaDB Ïó∞Í≤∞ Ïã§Ìå®:', err));

// OpenAI ÏÑ§Ï†ï
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// ÏïÑÏù¥Îîî Ï§ëÎ≥µ ÌôïÏù∏ API (Promise Í∏∞Î∞òÏúºÎ°ú ÏàòÏ†ï)
app.get('/check-userid', async (req, res) => {
  const { user_id } = req.query;
  const query = 'SELECT * FROM users WHERE user_id = ?';
  let conn;

  try {
    conn = await db.getConnection(); // DB Ïó∞Í≤∞
    const results = await conn.query(query, [user_id]);

    if (results.length > 0) {
      console.log(`[GET /check-userid] Ïù¥ÎØ∏ ÏÇ¨Ïö© Ï§ëÏù∏ ÏïÑÏù¥Îîî: ${user_id}`);
      return res.status(400).json({ message: 'Ïù¥ÎØ∏ ÏÇ¨Ïö© Ï§ëÏù∏ ÏïÑÏù¥ÎîîÏûÖÎãàÎã§.' });
    }
    console.log(`[GET /check-userid] ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏïÑÏù¥Îîî: ${user_id}`);
    return res.status(200).json({ message: 'ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏïÑÏù¥ÎîîÏûÖÎãàÎã§.' });
  } catch (err) {
    console.error('[GET /check-userid] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÌöåÏõêÍ∞ÄÏûÖ API
app.post('/signup', async (req, res) => {
  const { user_id, password, username } = req.body;
  let conn;

  try {
    conn = await db.getConnection();

    // ÎπÑÎ∞ÄÎ≤àÌò∏ Ìï¥Ïã±
    const hashedPassword = await bcrypt.hash(password, 10); // 10ÏùÄ salt rounds

    const query = 'INSERT INTO users (user_id, password, username) VALUES (?, ?, ?)';
    await conn.query(query, [user_id, hashedPassword, username]);

    console.log(`[POST /signup] ÌöåÏõêÍ∞ÄÏûÖ ÏÑ±Í≥µ - user_id: ${user_id}`);
    return res.status(201).json({ message: 'ÌöåÏõêÍ∞ÄÏûÖ ÏÑ±Í≥µ' });
  } catch (err) {
    console.error('[POST /signup] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// JWT Í≤ÄÏ¶ù ÎØ∏Îì§Ïõ®Ïñ¥
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer <token>

  if (!token) {
    return res.status(401).json({ message: 'Ïù∏Ï¶ù ÌÜ†ÌÅ∞Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÜ†ÌÅ∞ÏûÖÎãàÎã§.' });
    }
    req.user = user; // ÏöîÏ≤≠ Í∞ùÏ≤¥Ïóê ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï∂îÍ∞Ä
    next();
  });
};

// FCM ÌÜ†ÌÅ∞ Îì±Î°ù
app.post('/register-fcm-token', authenticateToken, async (req, res) => {
  const user_id = req.user.user_id;
  const { fcm_token } = req.body;

  if (!fcm_token) {
    return res.status(400).json({ message: 'fcm_tokenÏù¥ ÌïÑÏöîÌï©ÎãàÎã§' });
  }

  let conn;
  try {
    conn = await db.getConnection();

    const upsertQuery = `
      INSERT INTO user_tokens (user_id, fcm_token)
      VALUES (?, ?)
      ON DUPLICATE KEY UPDATE fcm_token = VALUES(fcm_token)
    `;

    await conn.query(upsertQuery, [user_id, fcm_token]);
    console.log(`[POST /register-fcm-token] FCM ÌÜ†ÌÅ∞ Îì±Î°ù ÏÑ±Í≥µ - ${user_id}`);
    return res.json({ message: 'ÌÜ†ÌÅ∞ Îì±Î°ù ÏÑ±Í≥µ' });
  } catch (err) {
    console.error('[POST /register-fcm-token] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

const EXPO_PUSH_API_URL = 'https://exp.host/--/api/v2/push/send';

async function sendPushNotificationToUser(farm_id, message) {
  let conn;
  try {
    conn = await db.getConnection();

    const [rows, fields] = await conn.query(
      `SELECT user_id FROM farms WHERE farm_id = ? LIMIT 1`,
      [farm_id]
    );
    console.log('[Expo Push] ÏÇ¨Ïö©Ïûê Ï°∞Ìöå rows:', rows);

    if (!rows || rows.length === 0 || !rows[0].user_id) {
      console.warn(`[Expo Push] ÏÇ¨Ïö©Ïûê ÏóÜÏùå - farm_id: ${farm_id}`);
      return;
    }

    const userId = rows[0].user_id;
    console.log(`[Expo Push] user_id: ${userId}`);

    const [tokenRows] = await conn.query(
      `SELECT fcm_token FROM user_tokens WHERE user_id = ? LIMIT 1`,
      [userId] // user.user_id ÎåÄÏã† userId ÏÇ¨Ïö©
    );
    const tokenRow = tokenRows[0];
    if (!tokenRow || !tokenRow.fcm_token) {
      console.warn(`[Expo Push] FCM ÌÜ†ÌÅ∞ ÏóÜÏùå - user_id: ${userId}`);
      return;
    }

    const expoToken = tokenRow.fcm_token;
    console.log(`[Expo Push] expoToken: ${expoToken}`);

    const payload = {
      to: expoToken,
      sound: 'default',
      title: 'üö® Ïä§ÎßàÌä∏Ìåú Í≤ΩÍ≥†',
      body: message,
      data: { farm_id },
    };

    console.log('[Expo Push] Ï†ÑÏÜ° payload:', JSON.stringify(payload));

    const response = await axios.post(EXPO_PUSH_API_URL, payload, {
      headers: {
        'Content-Type': 'application/json',
      },
    });

    console.log('[Expo Push] ÏïåÎ¶º Ï†ÑÏÜ° Í≤∞Í≥º:', response.data);
  } catch (err) {
    console.error('[Expo Push] ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', err);
  } finally {
    if (conn) conn.release();
  }
}

// Î°úÍ∑∏Ïù∏
app.post('/login', async (req, res) => {
  const { user_id, password } = req.body;
  const query = 'SELECT * FROM users WHERE user_id = ?';
  let conn;

  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [user_id]);

    if (results.length === 0) {
      return res.status(401).json({ message: 'Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïù¥Î©îÏùºÏûÖÎãàÎã§.' });
    }

    const user = results[0];

    // ÎπÑÎ∞ÄÎ≤àÌò∏ ÎπÑÍµê
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      console.log(`[POST /login] Î°úÍ∑∏Ïù∏ Ïã§Ìå®: ${user_id} - ÏûòÎ™ªÎêú ÎπÑÎ∞ÄÎ≤àÌò∏`);
      return res.status(401).json({ message: 'ÏûòÎ™ªÎêú ÎπÑÎ∞ÄÎ≤àÌò∏ÏûÖÎãàÎã§.' });
    }

    // JWT ÌÜ†ÌÅ∞ ÏÉùÏÑ±
    const token = jwt.sign(
      { user_id: user.user_id, username: user.username },
      JWT_SECRET,
      { expiresIn: '1h' } // ÌÜ†ÌÅ∞ ÎßåÎ£å ÏãúÍ∞Ñ (1ÏãúÍ∞Ñ)
    );

    console.log(`[POST /login] Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ: ${user_id}`);
    return res.json({
      message: 'Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ',
      token, // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê ÌÜ†ÌÅ∞ Î∞òÌôò
      user_id: user.user_id,
    });
  } catch (err) {
    console.error('[POST /login] DB Ïò§Î•ò:', err.stack);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ Î∂àÎü¨Ïò§Í∏∞
app.get('/getName', async (req,res) => {
  const user_id = req.query.user_id;
  const query = `SELECT username from users where user_id = ?`;
  let conn;

  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [user_id]);

    if (results.length > 0) {
      console.log('[GET /getName] ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ:',results[0].username);
      return res.json({ username: results[0].username });
    }
    console.log('[GET /getName] ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.')
    return res.status(404).json({ message:'ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' });
  } catch (err) {
    console.error('[GET /getName] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÎÜçÏû• Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞
app.get('/getFarms', async(req, res) => {
  const user_id = req.query.user_id;
  const query = `SELECT farm_id, farm_name, farm_location, farm_type, farm_active FROM farms WHERE user_id = ?`;
  let conn;

  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [user_id]);

    console.log('[GET /getFarms] ÎÜçÏû• Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞ ÏÑ±Í≥µ:', results);  // ÎÜçÏû• Î™©Î°ù Ï∂úÎ†•
    return res.json({ farms: results, message: 'ÎÜçÏû• Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞ ÏÑ±Í≥µ' });
  } catch (err) {
    console.error('[GET /getFarms] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÎÜçÏû• Ï∂îÍ∞ÄÌïòÍ∏∞
app.post('/addFarm', authenticateToken, async (req, res) => {
  const user_id = req.user.user_id; // JWTÏóêÏÑú Ï∂îÏ∂ú
  const { farm_name, farm_location, farm_type } = req.body;

  const insertFarmQuery = `
    INSERT INTO farms (user_id, farm_name, farm_location, farm_type)
    VALUES (?, ?, ?, ?)
  `;
  const insertDeviceQuery = `
    INSERT INTO devices (farm_id, led, fan, water, heater, cooler)
    VALUES (?, false, false, false, false, false)
  `;
  const selectCropConditionsQuery = `
    SELECT condition_type, min_value, optimal_min, optimal_max, max_value, unit
    FROM crop_conditions
    WHERE crop_type = ?
  `;
  const insertFarmConditionsQuery = `
    INSERT INTO farm_conditions (farm_id, condition_type, min_value, optimal_min, optimal_max, max_value, unit)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `;

  let conn;
  try {
    conn = await db.getConnection();
    await conn.beginTransaction();

    // 1. ÎÜçÏû• ÏÇΩÏûÖ
    const farmResult = await conn.query(insertFarmQuery, [user_id, farm_name, farm_location, farm_type]);
    const farm_id = parseInt(farmResult.insertId);
    console.log(`[POST /addFarm] ÎÜçÏû• Ï∂îÍ∞Ä ÏÑ±Í≥µ: user_id=${user_id}, farm_id=${farm_id}`);

    // 2. devices Ï¥àÍ∏∞Ìôî
    await conn.query(insertDeviceQuery, [farm_id]);
    console.log('[POST /addFarm] devices Ï¥àÍ∏∞Í∞í Ï∂îÍ∞Ä ÏÑ±Í≥µ');

    // 3. crop_conditionsÏóêÏÑú Ï°∞Í±¥ Î≥µÏÇ¨
    const cropConditions = await conn.query(selectCropConditionsQuery, [farm_type]);

    for (const row of cropConditions) {
      const { condition_type, min_value, optimal_min, optimal_max, max_value, unit } = row;
      await conn.query(insertFarmConditionsQuery, [
        farm_id, condition_type, min_value, optimal_min, optimal_max, max_value, unit
      ]);
    }
    console.log('[POST /addFarm] farm_conditions Î≥µÏÇ¨ ÏÑ±Í≥µ');

    // 4. ÌïòÎìúÏõ®Ïñ¥ ÏÑúÎ≤ÑÎ°ú farm_id, farm_type, ÏµúÏ†Å ÏàòÏπò Ï†ÑÏÜ°
    const optimalConditions = {};
    for (const row of cropConditions) {
      optimalConditions[row.condition_type] = {
        optimal_min: row.optimal_min,
        optimal_max: row.optimal_max
      };
    }

    try {
      await axios.post('https://api.hotpotato.me/init-farm-data', {
        farm_id,
        farm_type,
        conditions: optimalConditions
      });
      console.log(`[POST /addFarm] ÌïòÎìúÏõ®Ïñ¥ ÏÑúÎ≤ÑÎ°ú Ï†ÑÏÜ° ÏÑ±Í≥µ`);
    } catch (axiosError) {
      console.error(`[POST /addFarm] ÌïòÎìúÏõ®Ïñ¥ ÏÑúÎ≤Ñ Ï†ÑÏÜ° Ïã§Ìå®:`, axiosError.message);
    }

    await conn.commit();
    return res.json({ message: 'ÎÜçÏû• Ï∂îÍ∞Ä ÏÑ±Í≥µ', farm_id });
  } catch (err) {
    if (conn) await conn.rollback();
    console.error('[POST /addFarm] DB Ïò§Î•ò:', err.stack);
    return res.status(500).json({ message: 'DB Ïò§Î•ò', error: err.message });
  } finally {
    if (conn) conn.release();
  }
});

// ÎÜçÏû• ÏÇ≠Ï†ú
app.post('/delFarm', authenticateToken, async (req, res) => {
  const farmIds = req.body.farm_ids; // ÏöîÏ≤≠ bodyÏóêÏÑú farm_ids Î∞∞Ïó¥ Î∞õÍ∏∞
  const deleteDevicesQuery = `DELETE FROM devices WHERE farm_id IN (?)`;
  const deleteSensorsQuery = `DELETE FROM sensors WHERE farm_id IN (?)`;
  const deleteFarmsQuery = `DELETE FROM farms WHERE farm_id IN (?)`;
  let conn;

  try {
    conn = await db.getConnection();
    await conn.query(deleteDevicesQuery, [farmIds]);
    await conn.query(deleteSensorsQuery, [farmIds]);
    const farmResults = await conn.query(deleteFarmsQuery, [farmIds]);

    if (farmResults.affectedRows === 0) {
      return res.status(400).json({ message:'Ìï¥Îãπ ÎÜçÏû•Ïù¥ DBÏóê Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.' });
    }

    console.log('[Post /delFarm] ÏÇ≠Ï†úÎêú ÎÜçÏû• id:', farmIds);
    return res.json({ message: 'ÎÜçÏû• ÏÇ≠Ï†ú ÏÑ±Í≥µ' });
  } catch (err) {
    console.error('DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Î∞è Ïù¥ÏÉÅÍ∞í Í∞êÏßÄ
app.post('/sensors', async (req, res) => {
  const { farm_id, temperature, humidity, soil_moisture, co2, created_at } = req.body;

  const timestamp = created_at 
    ? moment.tz(created_at, "Asia/Seoul").format('YYYY-MM-DD HH:mm:ss') 
    : moment().tz("Asia/Seoul").format('YYYY-MM-DD HH:mm:ss');

  const insertQuery = `
    INSERT INTO sensors (farm_id, temperature, humidity, soil_moisture, co2, created_at)
    VALUES (?, ?, ?, ?, ?, ?)
  `;

  const conditionQuery = `
    SELECT condition_type, optimal_min, optimal_max 
    FROM farm_conditions 
    WHERE farm_id = ?
  `;

  let conn;

  try {
    conn = await db.getConnection();

    // 1. DBÏóê ÏÑºÏÑúÍ∞í Ï†ÄÏû•
    await conn.query(insertQuery, [farm_id, temperature, humidity, soil_moisture, co2, timestamp]);

    // 2. Ïù¥ÏÉÅÍ∞í Í∞êÏßÄ Î°úÏßÅ
    const conditions = await conn.query(conditionQuery, [farm_id]);

    if (!Array.isArray(conditions) || conditions.length === 0) {
      console.warn(`[POST /sensors] farm_id ${farm_id}Ïóê ÎåÄÌïú Ï°∞Í±¥ Ï†ïÎ≥¥ ÏóÜÏùå`);
    } else {
      const sensorValues = { temperature, humidity, soil_moisture, co2 };
      if (!global.abnormalSensorStatus) global.abnormalSensorStatus = {};

      for (const row of conditions) {
        const { condition_type, optimal_min, optimal_max } = row;
        const value = parseFloat(sensorValues[condition_type]);
        const key = `${farm_id}_${condition_type}`;
        const now = Date.now();
        const isOut = value < optimal_min || value > optimal_max;

        if (isOut) {
          if (!global.abnormalSensorStatus[key]) {
            global.abnormalSensorStatus[key] = { count: 1, firstTime: now, notified: false };
          } else {
            global.abnormalSensorStatus[key].count += 1;
          }

          if (global.abnormalSensorStatus[key].count >= 12 && !global.abnormalSensorStatus[key].notified) {
            global.abnormalSensorStatus[key].notified = true;
            await sendPushNotificationToUser(farm_id, `üì° ${condition_type} Í∞íÏù¥ 1Î∂Ñ Ïù¥ÏÉÅ Ïù¥ÏÉÅ ÏÉÅÌÉúÏûÖÎãàÎã§.`);
          }
        } else {
          delete global.abnormalSensorStatus[key];
        }
      }
    }

    return res.json({ message: 'ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏÑ±Í≥µ' });
  } catch (err) {
    console.error('[POST /sensors] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÏµúÍ∑º ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
app.get('/sensors/status', async (req, res) => {
  const { farm_id } = req.query;
  const query = `SELECT * FROM sensors WHERE farm_id = ? ORDER BY created_at DESC LIMIT 1`;
  let conn;

  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [farm_id]);
    if (results.length === 0) {
      console.log('[GET /sensors/status] Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
      return res.status(404).json({ message:'Ìï¥Îãπ Ï°∞Í±¥Ïóê ÎßûÎäî Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.' });
    }
    console.log('[GET /sensors/status] ÏÑºÏÑú Ï°∞Ìöå ÏÑ±Í≥µ');
    return res.json(results[0]); 
  } catch (err) {
    console.error('[GET /sensors/status] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// Ï†úÏñ¥Ïû•Ïπò ÏÉÅÌÉú Í∞ÄÏ†∏Ïò§Í∏∞
app.get('/devices/status', async(req, res) => {
  const { farm_id } = req.query;
  const query = `SELECT * FROM devices WHERE farm_id = ?`
  let conn;

  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [farm_id]);

    console.log('[GET /devices/status] Ï†úÏñ¥Ïû•Ïπò Ï°∞Ìöå ÏÑ±Í≥µ:');
    return res.json(results[0]);
  } catch (err) {
    console.error('[GET /devices/status] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// Ï†úÏñ¥Ïû•Ïπò ÏÉÅÌÉú Î≥ÄÍ≤ΩÌïòÍ∏∞
app.post('/devices/:deviceId/status', async (req, res) => {
  const { farm_id, device, status, content } = req.body;
  let conn;

  try {
    conn = await db.getConnection();
    await conn.beginTransaction(); // Ìä∏ÎûúÏû≠ÏÖò ÏãúÏûë

    // 1. devices ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
    const updateDeviceQuery = `UPDATE devices SET ${device} = ? WHERE farm_id = ?`;
    await conn.query(updateDeviceQuery, [status, farm_id]);
    console.log(`[/devices/:deviceId/status] Ï†úÏñ¥Ïû•Ïπò Î≥ÄÍ≤Ω ÏÑ±Í≥µ: ${device} -> ${status}`);

    // 2. ÏïåÎ¶º Ï∂îÍ∞Ä
    const alarmQuery = `INSERT INTO alarms (farm_id, content, type, device) VALUES (?, ?, ?, ?)`;
    const alarmType = status == 1 ? "Í≤ΩÍ≥†" : "ÏôÑÎ£å";
    await conn.query(alarmQuery, [farm_id, content, alarmType, device]);
    console.log(`[/devices/:deviceId/status] ${alarmType} ÏïåÎ¶º Ï∂îÍ∞Ä ÏÑ±Í≥µ`);

    // 3. device_logs ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏ (Ïû•ÏπòÍ∞Ä ÏºúÏßà ÎïåÎßå Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä)
    if (status == 1) {
      const today = moment().tz("Asia/Seoul").format("YYYY-MM-DD");
      const deviceLogQuery = `
        INSERT INTO device_logs (farm_id, date, device_type, operation_count)
        VALUES (?, ?, ?, 1)
        ON DUPLICATE KEY UPDATE operation_count = operation_count + 1
      `;
      await conn.query(deviceLogQuery, [farm_id, today, device]);
      console.log(`[/devices/:deviceId/status] ${device} ÏûëÎèô ÌöüÏàò Ï¶ùÍ∞Ä: farm_id=${farm_id}, date=${today}`);
    }

    await conn.commit(); // Ìä∏ÎûúÏû≠ÏÖò Ïª§Î∞ã
    return res.json({ message: 'Ï†úÏñ¥Ïû•Ïπò Î≥ÄÍ≤Ω Î∞è ÏïåÎ¶º, Î°úÍ∑∏ Ï∂îÍ∞Ä ÏÑ±Í≥µ' });
  } catch (err) {
    if (conn) await conn.rollback(); // Ïò§Î•ò Ïãú Î°§Î∞±
    console.error('[POST /devices/:deviceId/status] Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'ÏÑúÎ≤Ñ Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// Ï†úÏñ¥Ïû•Ïπò ÏÉÅÌÉú Í∞ïÏ†ú Î≥ÄÍ≤Ω
app.post('/devices/force-status', async (req, res) => {
  const { farm_id, device, status, duration } = req.body;

  if (!farm_id || !device || duration == null) {
    return res.status(400).json({ message: 'ÏûòÎ™ªÎêú ÏöîÏ≤≠ÏûÖÎãàÎã§. Î™®Îì† ÌïÑÎìú(farm_id, device, status, duration)Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.' });
  }

  const query = `UPDATE devices SET ${device} = ? WHERE farm_id = ?`;
  let conn;

  try {
    conn = await db.getConnection();
    await conn.query(query, [status, farm_id]);
    console.log(`[/devices/force-status] ${device} ÏÉÅÌÉú Î≥ÄÍ≤Ω ÏÑ±Í≥µ`);

    const status_val = status ? 1 : 0;

    // H/W ÏÑúÎ≤ÑÎ°ú ÏÉÅÌÉú + ÏßÄÏÜçÏãúÍ∞Ñ Ï†ÑÏÜ°
    await axios.post('https://api.hotpotato.me/update', {
      farm_id,
      devices: device,
      status: status_val,
      duration  // ÏßÄÏÜç ÏãúÍ∞Ñ (Ï¥à Îã®ÏúÑ)
    });

    console.log('[/devices/force-status] H/W ÏÑúÎ≤ÑÏóê ÏÉÅÌÉú Î∞è ÏßÄÏÜçÏãúÍ∞Ñ Ï†ÑÎã¨ ÏÑ±Í≥µ');
    return res.json({ message: 'Ï†úÏñ¥Ïû•Ïπò ÏÉÅÌÉú Í∞ïÏ†ú Î≥ÄÍ≤Ω ÏÑ±Í≥µ' });

  } catch (err) {
    console.error('[POST /devices/force-status] Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù' });
  } finally {
    if (conn) conn.release();
  }
});


// Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞ (1ÏãúÍ∞Ñ Îã®ÏúÑ ÌèâÍ∑†)
app.get('/realtime-data', async (req, res) => {
  const { farm_id } = req.query;
  const query = `
    SELECT 
      DATE_FORMAT(created_at, '%Y-%m-%d %H:00:00') AS time_interval,
      AVG(temperature) AS avg_temperature,
      AVG(humidity) AS avg_humidity,
      AVG(soil_moisture) AS avg_soil_moisture,
      AVG(co2) AS avg_co2
    FROM 
      sensors
    WHERE 
      farm_id = ? 
      AND created_at >= NOW() - INTERVAL 24 HOUR
    GROUP BY 
      time_interval
    ORDER BY 
      time_interval ASC;
  `;
  let conn;
  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [farm_id]);

    if (results.length === 0) {
      console.log('[GET /real-time-data] Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
      return res.status(404).json({ message:'Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.' });
    }

    console.log(`[GET /real-time-data] Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞: ${results.length}Í∞ú Î∞òÌôò`);
    return res.json(results);
  } catch (err) {
    console.error('[GET /realtime-data] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞ API (ÎÇ†ÏßúÎ≥Ñ ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞)
app.get('/history-data', async (req, res) => {
  const { farm_id, date } = req.query;

  // ÎÇ†Ïßú ÌååÏã± (YYYY-MM-DD ÌòïÌÉú)
  const formattedDate = new Date(date);

  // ÎÇ†ÏßúÍ∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏúºÎ©¥ Ïò§Î•ò Î∞òÌôò
  if (isNaN(formattedDate)) {
    return res.status(400).json({ message:'Ïú†Ìö®Ìïú ÎÇ†Ïßú ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§.' });
  }

  const start = new Date(formattedDate);
  start.setHours(0, 0, 0, 0);

  const end = new Date(formattedDate);
  end.setHours(23, 59, 59, 999);
 
  // 1ÏãúÍ∞Ñ Îã®ÏúÑÎ°ú Îç∞Ïù¥ÌÑ∞Î•º Í∑∏Î£πÌôîÌïòÏó¨ ÌèâÍ∑†Í∞í Í≥ÑÏÇ∞
  const query = `
    SELECT 
      DATE_FORMAT(created_at, '%Y-%m-%d %H:00:00') AS time_interval,
      AVG(temperature) AS avg_temperature,
      AVG(humidity) AS avg_humidity,
      AVG(soil_moisture) AS avg_soil_moisture,
      AVG(co2) AS avg_co2
    FROM 
      sensors
    WHERE 
      farm_id = ? 
      AND created_at BETWEEN ? AND ?
    GROUP BY 
      time_interval
    ORDER BY 
      time_interval ASC;
  `;
  let conn;

  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [farm_id, start, end]);
  
    if (results.length === 0) {
      console.log('[GET /history-data] Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
      return res.status(404).json({ message:'Ìï¥Îãπ ÎÇ†ÏßúÏóê Í∏∞Î°ùÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.' });
    }

    console.log(`[GET /history-data] Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞: ${results.length}Í∞ú Î∞òÌôò`);
    res.json(results);
  } catch (err) {
    console.error('[GET /history-data] DB Ïò§Î•ò: ', err.stack);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÏïåÎ¶º Î¶¨Ïä§Ìä∏ Î∂àÎü¨Ïò§Í∏∞
app.get('/getAlarm', async (req, res) => {
  const { farm_id } = req.query;
  const query = `SELECT  type, content, created_at, device FROM alarms 
                 WHERE farm_id = ?`;
  let conn;

  // ÌòÑÏû¨ ÎÇ†Ïßú Í∞ÄÏ†∏Ïò§Í∏∞ (ÌïúÍµ≠ ÏãúÍ∞Ñ Í∏∞Ï§Ä)
  // const now = new Date();
  // const year = now.getFullYear();
  // const month = String(now.getMonth() + 1).padStart(2, '0'); // ÏõîÏùÄ 0Î∂ÄÌÑ∞ ÏãúÏûë
  // const day = String(now.getDate()).padStart(2, '0');

  // const formattedDate = `${year}-${month}-${day}`;

  // const start = new Date(formattedDate);
  // start.setHours(0, 0, 0, 0);

  // const end = new Date(formattedDate);
  // end.setHours(23, 59, 59, 999);

  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [farm_id]);

    if (results.length === 0) {
      console.log('[GET /getAlarm] Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
      return res.status(404).json({ message: 'Ìï¥Îãπ ÎÇ†ÏßúÏóê Í∏∞Î°ùÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.' });
    } else {
      console.log(`[GET /getAlarm] ÏïåÎ¶º ${results.length}Í∞ú`);
      res.json(results);
    }
  } catch (err) {
    console.log('[GET /getAlarm] DB Ïò§Î•ò:', err.stack);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÎÜçÏû• ÏãúÏûë Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú farms ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
app.post('/start-farm', async (req, res) => {
  const { farmId } = req.body;
  
  // ÌòÑÏû¨ ÎÇ†Ïßú Íµ¨ÌïòÍ∏∞
  const currentDate = new Date().toISOString().split('T')[0];

  // farm_activeÎ•º TRUEÎ°ú, start_dateÎ•º ÌòÑÏû¨ ÎÇ†ÏßúÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
  const updateFarmQuery = `
    UPDATE farms
    SET farm_active = TRUE, start_date = ?
    WHERE farm_id = ?
  `;
  let conn;

  try {
    conn = await db.getConnection();

    // farms ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
    const updateResult = await conn.query(updateFarmQuery, [currentDate, farmId]);

    if (updateResult.affectedRows === 0) {
      return res.status(500).send('ÎÜçÏû• ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®');
    }

    // farm_typeÏóê ÎßûÎäî harvest_days Í∞ÄÏ†∏Ïò§Í∏∞
    const getCropQuery = `
      SELECT c.harvest_days
      FROM crops c
      JOIN farms f ON f.farm_type = c.name
      WHERE f.farm_id = ?
    `;
    
    // ÏûëÎ¨º Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    const cropResult = await conn.query(getCropQuery, [farmId]);

    if (cropResult.length === 0) {
      return res.status(500).send('ÏûëÎ¨º Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®');
    }

    const harvestDays = cropResult[0].harvest_days;

    console.log(`[POST /start-farm] ${farmId} ÎÜçÏû• ÏãúÏûë ÏÑ±Í≥µ `);
    res.json({ message: 'success', harvestDays, startDate: currentDate });
  } catch (err) {
    console.log('[POST /start-farm] DB Ïò§Î•ò:', err.stack);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÎÜçÏû• ÏÉÅÌÉúÎ•º Í∞ÄÏ†∏Ïò§Îäî API
app.get('/get-farm-status/:farmId', async (req, res) => {
  const farmId = req.params.farmId;

  const query = `
    SELECT f.farm_name, f.growth_rate, c.harvest_days, f.start_date, f.farm_active
    FROM farms f
    JOIN crops c ON f.farm_type = c.name
    WHERE f.farm_id = ?
  `;
  let conn;

  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [farmId]);

    // ÎÜçÏû• Ï†ïÎ≥¥Í∞Ä ÏóÜÏúºÎ©¥ 404 Î∞òÌôò
    if (results.length === 0) {
      return res.status(404).send('ÎÜçÏû• Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§.');
    }

    const { farm_name, growth_rate, harvest_days, start_date, farm_active } = results[0];

    // Í∞íÏù¥ ÏóÜÏúºÎ©¥ Ï≤òÎ¶¨
    if (farm_name === null || growth_rate === null || harvest_days === null || start_date === null || farm_active === null) {
      return res.status(400).json({ message: 'ÎÜçÏû• Ï†ïÎ≥¥Ïóê ÎàÑÎùΩÎêú Í∞íÏù¥ ÏûàÏäµÎãàÎã§.' });
    }

    // Ïò§Îäò ÎÇ†Ïßú Í≥ÑÏÇ∞
    const today = new Date();
    const startDate = new Date(start_date);
    const harvestDate = new Date(startDate);
    harvestDate.setDate(harvestDate.getDate() + harvest_days);

    // ÏàòÌôïÏùºÍπåÏßÄ ÎÇ®ÏùÄ ÏùºÏàò Í≥ÑÏÇ∞
    const timeDiff = harvestDate - today;
    const daysLeft = Math.ceil(timeDiff / (1000 * 3600 * 24)); // ÎÇ®ÏùÄ ÏùºÏàò Í≥ÑÏÇ∞

    // ÏÑ±Ïû•Î•† Í≥ÑÏÇ∞
    const progress = (harvest_days - daysLeft) / harvest_days;
    let newGrowthRate = progress * 100;

    // growth_rateÍ∞Ä Ïù¥ÎØ∏ ÏûàÏùÑ Í≤ΩÏö∞, Í∏∞Ï°¥ Í∞íÏóê ÎàÑÏ†ÅÌï¥ÏÑú Î∞òÏòÅ
    //if (growth_rate !== null) {
    //  newGrowthRate = Math.max(newGrowthRate, growth_rate);  // Í∏∞Ï°¥ ÏÑ±Ïû•Î•†Î≥¥Îã§ Îçî ÎÜíÏùÑ Ïàò ÏóÜÎèÑÎ°ù
    //}

    newGrowthRate = Math.min(newGrowthRate, 100); // 100%Î•º ÎÑòÏßÄ ÏïäÎèÑÎ°ù Ï≤òÎ¶¨

    // ÏÑ±Ïû•Î•† ÏÜåÏàòÏ†ê ÏóÜÏï†Í∏∞ (Ï†ïÏàòÎ°ú Î∞òÏòÅ)
    newGrowthRate = Math.round(newGrowthRate);

    // ÏÑ±Ïû•Î•† ÏóÖÎç∞Ïù¥Ìä∏
    const updateGrowthQuery = `
      UPDATE farms
      SET growth_rate = ?
      WHERE farm_id = ?
    `;
    await conn.query(updateGrowthQuery, [newGrowthRate, farmId]);

    // ÎÜçÏû• ÌôúÏÑ± ÏÉÅÌÉúÏóê Îî∞Î•∏ UI ÏóÖÎç∞Ïù¥Ìä∏
    if (farm_active === 1) {
      // farm_activeÍ∞Ä 1Ïùº Í≤ΩÏö∞, startButton Ïà®Í∏∞Í≥† cropInfo ÌëúÏãú
      // startButtonÏùÑ 'none'ÏúºÎ°ú Ïà®Í∏∞Í≥† cropInfoÎ•º 'visible'Î°ú ÌëúÏãú
      // Ïù¥ Î∂ÄÎ∂ÑÏùÄ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∏°ÏóêÏÑú Ï≤òÎ¶¨Ìï¥Ïïº ÌïòÎäî Î∂ÄÎ∂ÑÏûÖÎãàÎã§.
      console.log(`[GET /get-farm-status] ${farmId} ÎÜçÏû• D-DAY Ï°∞Ìöå ÏÑ±Í≥µ(ÌôúÏÑ±Ìôî)`);
      res.json({
        success: true,
        message: 'ÏÑ±Ïû•Î•† ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å',
        farm_name: farm_name,
        growthRate: newGrowthRate,
        harvestDays: harvest_days,
        startDate: start_date,
        farmActive: farm_active
      });
    } else {
      console.log(`[GET /get-farm-status] ${farmId} ÎÜçÏû• D-DAY Ï°∞Ìöå ÏÑ±Í≥µ(ÎπÑÌôúÏÑ±Ìôî)`);
      res.json({
        farm_name: farm_name,
        growthRate: newGrowthRate,
        harvestDays: harvest_days,
        startDate: start_date,
        farmActive: farm_active
      });
    }
  } catch (err) {
    console.log('[GET /get-farm-status] DB Ïò§Î•ò:', err.stack);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// Ï†úÏñ¥Ïû•Ïπò ÏÉÅÌÉú Í∞ÄÏ†∏Ïò§Í∏∞
app.get('/devices/status', async(req, res) => {
  const { farm_id } = req.query;
  const query = `SELECT * FROM devices WHERE farm_id = ?`
  let conn;

  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [farm_id]);

    console.log('[GET /devices/status] Ï†úÏñ¥Ïû•Ïπò Ï°∞Ìöå ÏÑ±Í≥µ:');
    return res.json(results[0]);
  } catch (err) {
    console.error('[GET /devices/status] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÏÑºÏÑúÎ≥Ñ ÏµúÏ†Å ÏàòÏπò Î∂àÎü¨Ïò§Í∏∞
app.get('/getFarmConditions/:farm_id', async(req, res) => {
  const farm_id = req.params.farm_id;
  const query = `
    SELECT condition_type, optimal_min, optimal_max
    FROM farm_conditions
    WHERE farm_id = ?
  `;

  let conn;
  try {
    conn = await db.getConnection();
    const results = await conn.query(query, [farm_id]);
    if (results.length === 0) {
      return res.status(404).json({ error: `${farm_id}ÎÜçÏû•Ïóê ÎåÄÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§` });
    }

    const conditions = {};
    results.forEach(row => {
      conditions[row.condition_type] = {
        optimal_min: row.optimal_min,
        optimal_max: row.optimal_max
      };
    });

    console.log('[GET /getFarmConditions] Ï°∞Ìöå ÏÑ±Í≥µ');
    return res.json(conditions);
  } catch (err) {
    console.error('[GET /getFarmConditions] DB Ïò§Î•ò:', err);
    return res.status(500).json({ message: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

// ÏÑºÏÑúÎ≥Ñ ÏµúÏ†Å ÏàòÏπò ÏóÖÎç∞Ïù¥Ìä∏
app.post('/updateFarmCondition', async (req, res) => {
  const {
    farm_id,
    temperature: { optimal_min: tempMin, optimal_max: tempMax },
    humidity: { optimal_min: humidMin, optimal_max: humidMax },
    soil_moisture: { optimal_min: soilMin, optimal_max: soilMax },
    co2: { optimal_min: co2Min, optimal_max: co2Max }
  } = req.body;

  if (!farm_id || !tempMin || !tempMax || !humidMin || !humidMax || !soilMin || !soilMax || !co2Min || !co2Max) {
    return res.status(400).json({ error: 'Î™®Îì† ÌïÑÎìúÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§' });
  }

  const updateQuery = `
    UPDATE farm_conditions 
    SET optimal_min = ?, optimal_max = ?
    WHERE farm_id = ? AND condition_type = ?
  `;

  const values = {
    temperature: [tempMin, tempMax],
    humidity: [humidMin, humidMax],
    soil_moisture: [soilMin, soilMax],
    co2: [co2Min, co2Max]
  };

  let conn;
  try {
    conn = await db.getConnection();
    
    // DB ÏóÖÎç∞Ïù¥Ìä∏
    for (const [type, [min, max]] of Object.entries(values)) {
      const result = await conn.query(updateQuery, [min, max, farm_id, type]);

      if (result.affectedRows === 0) {
        console.warn(`[POST /updateFarmCondition] Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå: ${farm_id} - ${type} (ÏóÖÎç∞Ïù¥Ìä∏ Ïïà Îê®)`);
      }
    }

    // ÌïòÎìúÏõ®Ïñ¥ ÏÑúÎ≤ÑÎ°ú ÏµúÏ†Å ÏàòÏπò Ï†ÑÏÜ°
    try {
      await axios.post('https://api.hotpotato.me/level', {
        temperature: { optimal_min: tempMin, optimal_max: tempMax },
        humidity: { optimal_min: humidMin, optimal_max: humidMax },
        soil_moisture: { optimal_min: soilMin, optimal_max: soilMax },
        co2: { optimal_min: co2Min, optimal_max: co2Max }
      });
      console.log(`[POST /updateFarmCondition] ÌïòÎìúÏõ®Ïñ¥ ÏÑúÎ≤ÑÎ°ú ${farm_id} ÎÜçÏû• ÏµúÏ†Å ÏàòÏπò Ï†ÑÏÜ° ÏôÑÎ£å`);
    } catch (axiosError) {
      console.error('[POST /updateFarmCondition] ÌïòÎìúÏõ®Ïñ¥ ÏÑúÎ≤Ñ Ï†ÑÏÜ° Ïò§Î•ò:', axiosError.message);
      // ÌïòÎìúÏõ®Ïñ¥ ÏÑúÎ≤Ñ Ï†ÑÏÜ° Ïã§Ìå® Ïãú, ÌïÑÏöîÏóê Îî∞Îùº ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê Í≤ΩÍ≥†Î•º Î∞òÌôòÌïòÍ±∞ÎÇò Î¨¥Ïãú
      // return res.status(500).json({ error: 'ÌïòÎìúÏõ®Ïñ¥ ÏÑúÎ≤Ñ Ï†ÑÏÜ° Ïã§Ìå®' });
    }

    console.log(`[POST /updateFarmCondition] ${farm_id}ÎÜçÏû• ÏµúÏ†Å ÏàòÏπò ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å`);
    return res.json({ message: `${farm_id}ÎÜçÏû•Ïùò ÏµúÏ†Å ÏàòÏπòÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§` });
  } catch (err) {
    console.error('[POST /updateFarmCondition] DB Ïò§Î•ò:', err);
    return res.status(500).json({ error: 'DB Ïò§Î•ò' });
  } finally {
    if (conn) conn.release();
  }
});

app.post("/chatbot", async (req, res) => {
  const userMessage = req.body.message;

  if (!userMessage) {
    return res.status(400).json({ error: "Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî." });
  }

  try {
    const openaiRes = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: userMessage }]
      })
    });

    const data = await openaiRes.json();
    const reply = data.choices?.[0]?.message?.content || "ÎãµÎ≥ÄÏùÑ Í∞ÄÏ†∏Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.";
    res.json({ reply });
  } catch (err) {
    console.error("OpenAI Ìò∏Ï∂ú Ïò§Î•ò:", err);
    res.status(500).json({ error: "OpenAI Ìò∏Ï∂ú Ï§ë Ïò§Î•ò Î∞úÏÉù" });
  }
});

// reports ÌÖåÏù¥Î∏î ÏÉùÏÑ± (ÏµúÏ¥à Ïã§Ìñâ Ïãú)
async function initializeDatabase() {
  let conn;
  try {
    conn = await db.getConnection();
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS reports (
        id INT AUTO_INCREMENT PRIMARY KEY,
        farm_id INT NOT NULL,
        date DATE NOT NULL,
        sensor_summary JSON NOT NULL,
        sensor_changes JSON NOT NULL,
        device_logs JSON NOT NULL,
        ai_analysis TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(farm_id, date),
        FOREIGN KEY (farm_id) REFERENCES farms(farm_id) ON DELETE CASCADE
      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
    `;
    await conn.query(createTableQuery);
    console.log('Reports ÌÖåÏù¥Î∏î ÏÉùÏÑ± ÏÑ±Í≥µ');
  } catch (err) {
    console.error('Reports ÌÖåÏù¥Î∏î ÏÉùÏÑ± Ïã§Ìå®:', err);
  } finally {
    if (conn) conn.release();
  }
}

// ÏÑúÎ≤Ñ ÏãúÏûë Ïãú ÌÖåÏù¥Î∏î Ï¥àÍ∏∞Ìôî
initializeDatabase();

// Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÏóîÎìúÌè¨Ïù∏Ìä∏
app.post('/generate-report', async (req, res) => {
  let conn;
  try {
    console.log('Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÏöîÏ≤≠ ÏàòÏã†:', req.body);
    const { farmId, date } = req.body;

    // ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù
    if (!farmId || !date) {
      return res.status(400).json({ error: 'farmIdÏôÄ dateÎäî ÌïÑÏàòÏûÖÎãàÎã§' });
    }

    // ÎÇ†Ïßú ÌòïÏãù Í≤ÄÏ¶ù
    const datePattern = /^\d{4}-\d{2}-\d{2}$/;
    if (!datePattern.test(date)) {
      return res.status(400).json({ error: 'Ïú†Ìö®Ìïú ÎÇ†Ïßú ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§ (YYYY-MM-DD)' });
    }

    // DB Ïó∞Í≤∞
    console.log('Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏãúÎèÑ');
    conn = await db.getConnection();
    console.log('Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞:', conn ? 'ÏÑ±Í≥µ' : 'Ïã§Ìå®');

    // Ï§ëÎ≥µ Î¶¨Ìè¨Ìä∏ ÌôïÏù∏
    console.log('Ï§ëÎ≥µ Î¶¨Ìè¨Ìä∏ ÌôïÏù∏');
    const queryResult = await conn.query(
      'SELECT id FROM reports WHERE farm_id = ? AND date = ?',
      [farmId, date]
    );
    console.log('Ï§ëÎ≥µ Î¶¨Ìè¨Ìä∏ Ï°∞Ìöå Í≤∞Í≥º:', queryResult);

    // MariaDB Î≤ÑÏ†ÑÏóê Îî∞Îùº Í≤∞Í≥º Ï≤òÎ¶¨
    let existingReport = Array.isArray(queryResult) ? queryResult : queryResult?.rows || [];
    console.log('Í∏∞Ï°¥ Î¶¨Ìè¨Ìä∏:', existingReport);

    if (existingReport.length > 0) {
      return res.status(409).json({ error: 'Ìï¥Îãπ ÎÇ†ÏßúÏùò Î¶¨Ìè¨Ìä∏Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§.' });
    }

    // ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
    console.log('ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå');
    let historyData;
    try {
      historyData = await fetchHistoryDataFromDB(farmId, date);
    } catch (error) {
      return res.status(400).json({ error: error.message });
    }

    if (!historyData || !historyData.timeLabels || !historyData.timeLabels.length) {
      return res.status(400).json({ error: 'Ìï¥Îãπ ÎÇ†ÏßúÏùò ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§' });
    }

    // ÎÇòÎ®∏ÏßÄ ÏΩîÎìú (sensorSummary, sensorChanges, deviceLogs, OpenAI, DB Ï†ÄÏû• Îì±)
    const sensorSummary = {
      avg_temperature: roundToTwo(average(historyData.temperatureData)),
      avg_humidity: roundToTwo(average(historyData.humidityData)),
      avg_soil_moisture: roundToTwo(average(historyData.soilData)),
      avg_co2: roundToTwo(average(historyData.co2Data)),
    };

    const sensorChanges = {
      max_temperature: {
        value: Math.max(...historyData.temperatureData),
        time: historyData.timeLabels[historyData.temperatureData.indexOf(Math.max(...historyData.temperatureData))],
      },
      min_temperature: {
        value: Math.min(...historyData.temperatureData),
        time: historyData.timeLabels[historyData.temperatureData.indexOf(Math.min(...historyData.temperatureData))],
      },
      max_humidity: {
        value: Math.max(...historyData.humidityData),
        time: historyData.timeLabels[historyData.humidityData.indexOf(Math.max(...historyData.humidityData))],
      },
      min_humidity: {
        value: Math.min(...historyData.humidityData),
        time: historyData.timeLabels[historyData.humidityData.indexOf(Math.min(...historyData.humidityData))],
      },
      max_soil_moisture: {
        value: Math.max(...historyData.soilData),
        time: historyData.timeLabels[historyData.soilData.indexOf(Math.max(...historyData.soilData))],
      },
      min_soil_moisture: {
        value: Math.min(...historyData.soilData),
        time: historyData.timeLabels[historyData.soilData.indexOf(Math.min(...historyData.soilData))],
      },
      max_co2: {
        value: Math.max(...historyData.co2Data),
        time: historyData.timeLabels[historyData.co2Data.indexOf(Math.max(...historyData.co2Data))],
      },
      min_co2: {
        value: Math.min(...historyData.co2Data),
        time: historyData.timeLabels[historyData.co2Data.indexOf(Math.min(...historyData.co2Data))],
      },
    };

    // Ï†úÏñ¥ Ïû•Ïπò Î°úÍ∑∏ Ï°∞Ìöå
    console.log('Ï†úÏñ¥ Ïû•Ïπò Ï°∞Ìöå');
    const deviceLogs = await fetchDeviceLogs(farmId, date);

    // AI Î∂ÑÏÑù ÏÉùÏÑ±
    console.log('AI Î∂ÑÏÑù ÏÉùÏÑ±');
    const prompt = `
      Ïä§ÎßàÌä∏Ìåú ÏùºÏùº Î¶¨Ìè¨Ìä∏Î•º Î∂ÑÏÑùÌïòÍ≥† ÏöîÏïΩÌï¥Ï£ºÏÑ∏Ïöî. Îã§Ïùå Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Î∞òÏúºÎ°ú:

      1. ÏÑºÏÑú Ï∏°Ï†ï ÏöîÏïΩ:
      ${JSON.stringify(sensorSummary, null, 2)}

      2. ÏÑºÏÑú ÏàòÏπò Î≥ÄÌôî:
      ${JSON.stringify(sensorChanges, null, 2)}

      3. Ï†úÏñ¥ Ïû•Ïπò ÏûëÎèô Í∏∞Î°ù:
      ${JSON.stringify(deviceLogs, null, 2)}

      Ï∂úÎ†• ÌòïÏãù:
      - Ïò§Îäò Ïò®ÎèÑÎäî [ÏïàÏ†ïÏ†Å/Î≥ÄÎèôÏù¥ Ïã¨Ìï®]ÌñàÏäµÎãàÎã§.
      - ÏäµÎèÑÎäî [Ï†ÅÏ†ï ÏàòÏ§Ä/ÎÇÆÏùÄ Í≤ΩÌñ•/ÎÜíÏùÄ Í≤ΩÌñ•]ÏùÑ Î≥¥ÏòÄÏäµÎãàÎã§.
      - ÌÜ†Ïñë ÏàòÎ∂ÑÏùÄ [Ï∂©Î∂Ñ/Î∂ÄÏ°±/Í≥ºÎã§] ÏÉÅÌÉúÎ•º Ïú†ÏßÄÌñàÏäµÎãàÎã§.
      - CO‚ÇÇ ÎÜçÎèÑÎäî [ÏïàÏ†ïÏ†Å/Î≥ÄÎèô ÏûàÏùå]ÏòÄÏäµÎãàÎã§.
      - Ï£ºÏöî Î¨∏Ï†úÏ†ê: (Î¨∏Ï†úÏ†ê ÏÑ§Î™Ö)
      - Í∞úÏÑ† Ï†úÏïà: (Í∞úÏÑ† Ï†úÏïà)
    `;

    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        { role: 'system', content: 'ÎãπÏã†ÏùÄ Ïä§ÎßàÌä∏Ìåú Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§.' },
        { role: 'user', content: prompt },
      ],
      max_tokens: 600,
    });

    const aiAnalysis = response.choices[0].message.content.trim();
    
    // Î¶¨Ìè¨Ìä∏ Ï†ÄÏû•
    console.log('Î¶¨Ìè¨Ìä∏ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû•');
    const insertQuery = `
      INSERT INTO reports (farm_id, date, sensor_summary, sensor_changes, device_logs, ai_analysis)
      VALUES (?, ?, ?, ?, ?, ?)
    `;
    const result = await conn.query(insertQuery, [
      farmId,
      date,
      JSON.stringify(sensorSummary),
      JSON.stringify(sensorChanges),
      JSON.stringify(deviceLogs),
      aiAnalysis,
    ]);

    const reportText = `
üìã Ïä§ÎßàÌä∏Ìåú ÏùºÏùº Î¶¨Ìè¨Ìä∏
1. ÎÇ†Ïßú
${date}

2. ÏÑºÏÑú Ï∏°Ï†ï ÏöîÏïΩ
ÌèâÍ∑† Ïò®ÎèÑ: ${sensorSummary.avg_temperature} ‚ÑÉ
ÌèâÍ∑† ÏäµÎèÑ: ${sensorSummary.avg_humidity} %
ÌèâÍ∑† ÌÜ†Ïñë ÏàòÎ∂Ñ: ${sensorSummary.avg_soil_moisture} %
ÌèâÍ∑† CO‚ÇÇ ÎÜçÎèÑ: ${sensorSummary.avg_co2} ppm

3. ÏÑºÏÑú ÏàòÏπò Î≥ÄÌôî
ÏµúÍ≥† Ïò®ÎèÑ: ${sensorChanges.max_temperature.value} ‚ÑÉ (ÏãúÍ∞Ñ: ${sensorChanges.max_temperature.time})
ÏµúÏ†Ä Ïò®ÎèÑ: ${sensorChanges.min_temperature.value} ‚ÑÉ (ÏãúÍ∞Ñ: ${sensorChanges.min_temperature.time})
ÏµúÍ≥† ÏäµÎèÑ: ${sensorChanges.max_humidity.value} % (ÏãúÍ∞Ñ: ${sensorChanges.max_humidity.time})
ÏµúÏ†Ä ÏäµÎèÑ: ${sensorChanges.min_humidity.value} % (ÏãúÍ∞Ñ: ${sensorChanges.min_humidity.time})
ÏµúÍ≥† ÌÜ†Ïñë ÏàòÎ∂Ñ: ${sensorChanges.max_soil_moisture.value} % (ÏãúÍ∞Ñ: ${sensorChanges.max_soil_moisture.time})
ÏµúÏ†Ä ÌÜ†Ïñë ÏàòÎ∂Ñ: ${sensorChanges.min_soil_moisture.value} % (ÏãúÍ∞Ñ: ${sensorChanges.min_soil_moisture.time})
ÏµúÍ≥† CO‚ÇÇ ÎÜçÎèÑ: ${sensorChanges.max_co2.value} ppm (ÏãúÍ∞Ñ: ${sensorChanges.max_co2.time})
ÏµúÏ†Ä CO‚ÇÇ ÎÜçÎèÑ: ${sensorChanges.min_co2.value} ppm (ÏãúÍ∞Ñ: ${sensorChanges.min_co2.time})

4. Ï†úÏñ¥ Ïû•Ïπò ÏûëÎèô Í∏∞Î°ù
LED: ${deviceLogs.led.start ? `ÏºúÏßê(ÏãúÏûë: ${deviceLogs.led.start}, Ï¢ÖÎ£å: ${deviceLogs.led.end})` : 'Í∫ºÏßê'}
ÌôòÍ∏∞Ìå¨: ÏûëÎèô ÌöüÏàò ${deviceLogs.fan.count}Ìöå, Ï¥ù ÏûëÎèô ÏãúÍ∞Ñ ${deviceLogs.fan.total_time}Î∂Ñ
Í∏âÏàòÏû•Ïπò: Í∏âÏàò ÌöüÏàò ${deviceLogs.water.count}Ìöå, Ï¥ù Í∏âÏàòÎüâ ${deviceLogs.water.total_amount} L
ÌûàÌÑ∞: ÏûëÎèô ÌöüÏàò ${deviceLogs.heater.count}Ìöå, Ï¥ù ÏûëÎèô ÏãúÍ∞Ñ ${deviceLogs.heater.total_time}Î∂Ñ
Ïø®Îü¨: ÏûëÎèô ÌöüÏàò ${deviceLogs.cooler.count}Ìöå, Ï¥ù ÏûëÎèô ÏãúÍ∞Ñ ${deviceLogs.cooler.total_time}Î∂Ñ

5. AI Î∂ÑÏÑù Î∞è ÏöîÏïΩ
${aiAnalysis}
    `;

    res.json({ reportText, reportId: Number(result.insertId) });
  } catch (error) {
    console.error('Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ïò§Î•ò:', error);
    if (error.code === 'ER_DUP_ENTRY') {
      return res.status(409).json({ error: 'Ìï¥Îãπ ÎÇ†ÏßúÏùò Î¶¨Ìè¨Ìä∏Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§.' });
    }
    res.status(500).json({ error: `Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: ${error.message}` });
  } finally {
    if (conn) conn.release();
  }
});

// Î¶¨Ìè¨Ìä∏ ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
async function fetchHistoryDataFromDB(farmId, date) {
  try {
    console.log(`ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë - ÎÜçÏû• ID: ${farmId}, ÎÇ†Ïßú: ${date}`);
    
    // /history-data API Ìò∏Ï∂ú
    const response = await fetch(`${API_BASE_URL}/history-data?farm_id=${farmId}&date=${date}`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' },
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§');
    }

    const historyData = await response.json();

    if (!historyData || historyData.length === 0) {
      throw new Error('Ìï¥Îãπ ÎÜçÏû•Í≥º ÎÇ†ÏßúÏóê ÎåÄÌïú ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§');
    }

    // /history-dataÏùò ÏùëÎãµÏùÑ /generate-reportÏóê ÎßûÍ≤å Í∞ÄÍ≥µ
    const result = {
      timeLabels: historyData.map(row => new Date(row.time_interval).toISOString().slice(11, 16)),
      temperatureData: historyData.map(row => Number(row.avg_temperature) || 0),
      humidityData: historyData.map(row => Number(row.avg_humidity) || 0),
      soilData: historyData.map(row => Number(row.avg_soil_moisture) || 0),
      co2Data: historyData.map(row => Number(row.avg_co2) || 0),
    };

    console.log('Í∞ÄÍ≥µÎêú ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞:', result);
    return result;
  } catch (error) {
    console.error(`ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå® - ÎÜçÏû• ID: ${farmId}, ÎÇ†Ïßú: ${date}`, error);
    throw new Error(`ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®: ${error.message}`);
  }
}

// [Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±] Ïû•Ïπò ÏÉÅÌÉú Ï°∞Ìöå 
async function fetchDeviceLogs(farmId, date) {
  let conn;
  try {
    conn = await db.getConnection();
    const query = `
      SELECT device_type, operation_count, total_duration
      FROM device_logs
      WHERE farm_id = ? AND date = ?
    `;
    const result = await conn.query(query, [farmId, date]);
    
    // Í∏∞Î≥∏ Ïû•Ïπò Î°úÍ∑∏ Í∞ùÏ≤¥
    const deviceLogs = {
      led: { count: 0, total_time: 0 },
      fan: { count: 0, total_time: 0 },
      water: { count: 0, total_amount: 0 },
      heater: { count: 0, total_time: 0 },
      cooler: { count: 0, total_time: 0 },
    };

    // Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Î∞òÏúºÎ°ú deviceLogs Ï±ÑÏö∞Í∏∞
    result.forEach(row => {
      if (row.device_type === 'led') {
        deviceLogs.led.count = row.operation_count;
        deviceLogs.led.total_time = row.total_duration || 0;
        // LEDÏùò Í≤ΩÏö∞ ÏãúÏûë/Ï¢ÖÎ£å ÏãúÍ∞ÑÏùÄ ÏûÑÏùòÎ°ú ÏÑ§Ï†ï (ÌïÑÏöî Ïãú Î≥ÑÎèÑ Î°úÏßÅ Ï∂îÍ∞Ä)
        deviceLogs.led.start = row.operation_count > 0 ? '08:00' : null;
        deviceLogs.led.end = row.operation_count > 0 ? '18:00' : null;
      } else if (row.device_type === 'fan') {
        deviceLogs.fan.count = row.operation_count;
        deviceLogs.fan.total_time = row.total_duration || 0;
      } else if (row.device_type === 'water') {
        deviceLogs.water.count = row.operation_count;
        deviceLogs.water.total_amount = row.operation_count * 3.33; // Ïòà: 1ÌöåÎãπ 3.33LÎ°ú Í∞ÄÏ†ï
      } else if (row.device_type === 'heater') {
        deviceLogs.heater.count = row.operation_count;
        deviceLogs.heater.total_time = row.total_duration || 0;
      } else if (row.device_type === 'cooler') {
        deviceLogs.cooler.count = row.operation_count;
        deviceLogs.cooler.total_time = row.total_duration || 0;
      }
    });

    console.log(`[fetchDeviceLogs] farmId: ${farmId}, date: ${date}`, deviceLogs);
    return deviceLogs;
  } catch (error) {
    console.error(`[fetchDeviceLogs] Ïò§Î•ò: farmId=${farmId}, date=${date}`, error);
    throw new Error('Ïû•Ïπò Î°úÍ∑∏ Ï°∞Ìöå Ïã§Ìå®');
  } finally {
    if (conn) conn.release();
  }
}

// [Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±] ÌèâÍ∑† Í≥ÑÏÇ∞
function average(arr) {
  return arr.reduce((sum, val) => sum + val, 0) / arr.length;
}

// [Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±] ÏÜåÏàòÏ†ê ÎëòÏß∏ ÏûêÎ¶¨ Î∞òÏò¨Î¶º
function roundToTwo(num) {
  return Math.round(num * 100) / 100;
}

// Î¶¨Ìè¨Ìä∏ Î∂àÎü¨Ïò§Í∏∞Í∏∞
app.get('/get-reports/:farmId', async (req, res) => {
  let conn;
  try {
    const { farmId } = req.params;
    conn = await db.getConnection();
    const selectQuery = `
      SELECT id, farm_id, date, sensor_summary, sensor_changes, device_logs, ai_analysis, created_at
      FROM reports
      WHERE farm_id = ?
      ORDER BY created_at DESC
      LIMIT 10
    `;
    const reports = await conn.query(selectQuery, [farmId]);

    const formattedReports = reports.map(report => {
      // JSON ÌïÑÎìúÍ∞Ä Î¨∏ÏûêÏó¥Ïù∏ÏßÄ Í∞ùÏ≤¥Ïù∏ÏßÄ ÌôïÏù∏
      const sensorSummary = typeof report.sensor_summary === 'string' ? JSON.parse(report.sensor_summary) : report.sensor_summary;
      const sensorChanges = typeof report.sensor_changes === 'string' ? JSON.parse(report.sensor_changes) : report.sensor_changes;
      const deviceLogs = typeof report.device_logs === 'string' ? JSON.parse(report.device_logs) : report.device_logs;

      return {
        id: Number(report.id), // BigIntÎ•º NumberÎ°ú Î≥ÄÌôò
        farmId: Number(report.farm_id),
        date: report.date.toISOString().split('T')[0],
        sensorSummary,
        sensorChanges,
        deviceLogs,
        aiAnalysis: report.ai_analysis,
        createdAt: report.created_at
      };
    });

    res.json(formattedReports);
  } catch (error) {
    console.error('Î¶¨Ìè¨Ìä∏ Ï°∞Ìöå Ïò§Î•ò:', error);
    res.status(500).json({ error: 'Î¶¨Ìè¨Ìä∏ Ï°∞Ìöå Ïã§Ìå®' });
  } finally {
    if (conn) conn.release();
  }
});

app.listen(PORT, '0.0.0.0', () => {
  console.log('ÏÑúÎ≤ÑÍ∞Ä Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§.');
});